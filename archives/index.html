<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Archive
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="Jacob&#39;s blog">
<meta property="og:url" content="/blog/archives/index.html">
<meta property="og:site_name" content="Jacob&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jacob&#39;s blog">


  <link rel="alternative" href="/atom.xml" title="Jacob&#39;s blog" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/blog/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/blog/styles/main.css">






</head>
<body class="monochrome">
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/blog/">Jacob&#39;s blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/blog/">Jacob&#39;s blog</a></h1>
    
      <p class="subtitle">
        notebook
      </p>
    
    <div class="info">
      <div class="content">
        
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/blog/images/cc/about.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/markdown基本用法/">markdown基本用法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/teammates/">teammates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/语言基础/">语言基础</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/面试经历/">面试经历</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/">2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/">2018</a><span class="archive-list-count">21</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/blog/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/blog/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://fatty.github.io/blog/archives/" title="沈赵" target="_blank" rel="noopener">沈赵</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/Fatty" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="/blog/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/blog/archives/2019" class="archive-year">2019</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/设计模式-适配器模式/">
  适配器模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/设计模式-适配器模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将各种截然不同的函数接口封装成统一的API。 </p>
<p>例如：PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。</p>
<p>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。</p>
<pre><code>&lt;?php
</code></pre><p>interface IDatabase<br>{<br>    function connect($host, $user, $passwd, $dbname);<br>    function query($sql);<br>    function close();<br>}<br>class MySQL implements IDatabase<br>{<br>    protected $conn;<br>    function connect($host, $user, $passwd, $dbname)<br>    {<br>        $conn = mysql_connect($host, $user, $passwd);<br>        mysql_select_db($dbname, $conn);<br>        $this-&gt;conn = $conn;<br>    }</p>
<pre><code>function query($sql)
{
    $res = mysql_query($sql, $this-&gt;conn);
    return $res;
}

function close()
{
    mysql_close($this-&gt;conn);
}
</code></pre><p>}<br>class MySQLi implements IDatabase<br>{<br>    protected $conn;</p>
<pre><code>function connect($host, $user, $passwd, $dbname)
{
    $conn = mysqli_connect($host, $user, $passwd, $dbname);
    $this-&gt;conn = $conn;
}

function query($sql)
{
    return mysqli_query($this-&gt;conn, $sql);
}

function close()
{
    mysqli_close($this-&gt;conn);
}
</code></pre><p>}</p>
<p>class PDO1 implements IDatabase<br>{<br>    protected $conn;<br>    function connect($host, $user, $passwd, $dbname)<br>    {<br>        $conn = new \PDO(“mysql:host=$host;dbname=$dbname”, $user, $passwd);<br>        $this-&gt;conn = $conn;<br>    }</p>
<pre><code>function query($sql)
{
    return $this-&gt;conn-&gt;query($sql);
}

function close()
{
    unset($this-&gt;conn);
}
</code></pre><p>}<br>$db = new PDO1();<br>$db-&gt;connect(‘127.0.0.1’, ‘root’, ‘root’, ‘test’);<br>$db-&gt;query(‘show databases’);<br>$db-&gt;close();</p>
<p>$db = MySQLi ();<br>$db-&gt;connect(‘127.0.0.1’, ‘root’, ‘root’, ‘test’);<br>$db-&gt;query(‘show databases’);<br>$db-&gt;close();</p>
<p>$db = MySQl();<br>$db-&gt;connect(‘127.0.0.1’, ‘root’, ‘root’, ‘test’);<br>$db-&gt;query(‘show databases’);<br>$db-&gt;close();</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/创建模式/">
  建造者模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/创建模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式主要用于创建复杂对象，将复杂对象的表示与构造分离。</p>
<p>例子：<br>    &lt;?php<br>/**</p>
<ul>
<li></li>
<li>产品本身<br>*/<br>class Product {<br> private $_parts;<br> public function __construct() { $this-&gt;_parts = array(); }<br> public function add($part) { return array_push($this-&gt;_parts, $part); }<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>建造者抽象类<br><em>
</em>/<br>abstract class Builder {<br> public abstract function buildPart1();<br> public abstract function buildPart2();<br> public abstract function getResult();<br>}</li>
</ul>
<p>/**</p>
<ul>
<li></li>
<li>具体建造者</li>
<li>实现其具体方法<br>*/<br>class ConcreteBuilder extends Builder {<br> private $_product;<br> public function __construct() { $this-&gt;_product = new Product(); }<br> public function buildPart1() { $this-&gt;_product-&gt;add(“Part1”); }<br> public function buildPart2() { $this-&gt;_product-&gt;add(“Part2”); }<br> public function getResult() { return $this-&gt;_product; }<br>}<br>/**<ul>
<li><em>导演者
</em>/<br>class Director {<br>public function __construct(Builder $builder) {<br>   $builder-&gt;buildPart1();//导演指挥具体建造者生产产品<br>   $builder-&gt;buildPart2();<br>}<br>}</li>
</ul>
</li>
</ul>
<p>// client<br>$buidler = new ConcreteBuilder();<br>$director = new Director($buidler);<br>$product = $buidler-&gt;getResult();<br>echo “<pre>“;<br>var_dump($product);<br>echo “</pre>“;<br>/<em>输出： object(Product)#2 (1) {<br>[“_parts”:”Product”:private]=&gt;<br>array(2) {<br>    [0]=&gt;string(5) “Part1”<br>    [1]=&gt;string(5) “Part2”<br>}<br>} </em>/<br>?&gt;</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/设计模式-简单工厂模式/">
  简单工厂模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/设计模式-简单工厂模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式属于创建型模式，又叫做静态工厂方法模式，单不属于23中GOF设计模式之一。简单工厂模式是由一个工厂决定创建出哪一种产品类的实例，可以理解为不同工厂模式的一个特殊实现。</p>
<ul>
<li>优点：根据外界给定的信息决定究竟应该创建哪个具体类的对象，明确区分了各自的职责和权力，有利于整个软件提结构的优化。</li>
<li>缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。</li>
<li>抽象基类：类中定义一些方法，用以在子类中实现。</li>
<li>继承自抽象基类的子类：实现基类中的抽象方法。</li>
<li>工厂类：用以实例化所有对应的子类。</li>
<li>实例代码：<br>  class SimpleFactoryPattern {<br>  public static function createObj($op){<pre><code>switch ($op){
    case &apos;+&apos; :
        return new OperationAdd();
        break;
    case &apos;-&apos; :
        return new OperationSub();
        break;
    case &apos;*&apos; :
        return new OperationMul();
        break;
    case &apos;/&apos; :
        return new OperationDivide();
    default :
        break;
}
</code></pre>  }<br>}<br>/<em> 抽象类 </em>/<br>abstract class Operation{<br>  abstract public function getValue($num1,$num2);<br>}</li>
</ul>
<p>class OperationAdd extends Operation {<br>    public function getValue($num1, $num2) {<br>        return $num1 + $num2;<br>    }<br>}</p>
<p>class OperationSub extends Operation {<br>    public function getValue($num1, $num2) {<br>        return $num1 - $num2;<br>    }<br>}</p>
<p>class OperationMul extends Operation {<br>    public function getValue($num1, $num2) {<br>        return $num1 * $num2;<br>    }<br>}</p>
<p>class OperationDivide extends Operation {<br>    public function getValue($num1, $num2) {<br>        try {<br>            if($num2 == 0){<br>                throw new Exception(“除数不能为0”);<br>            }else{<br>                return $num1 / $num2;<br>            }<br>        } catch (Exception $exc) {<br>            echo “error：”.$exc-&gt;getTraceAsString();<br>        }<br>    }<br>}</p>
<p>$test = SimpleFactoryPattern::createObj(‘/‘);<br>$result = $test-&gt;getValue(10, 1);<br>echo $result;</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/设计模式-单例模式/">
  单例模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/设计模式-单例模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul>
<li>单例模式，作为对象的创建模式，单例模式确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li>
<li>特点</li>
</ul>
<ol>
<li>一个类只能有一个实例；</li>
<li>必须自行创建这个实例；</li>
<li>必须向整个系统提供这个实例；</li>
</ol>
<ul>
<li>为什么使用单模式？</li>
<li>用于数据库应用时，可以避免大量的new操作消耗资源，减少数据库连接。</li>
<li>如果系统需要有一个类来全局控制某些配置信息时，那么单例模式可以很方便的实现。</li>
<li>在页面请求中，便于调试，因为所有代码都在一个类中，可以在类中设置钩子，从而有效避免到处var_dump,echo。</li>
<li>例子</li>
<li>`&lt;?php</li>
</ul>
<p>/**</p>
<ul>
<li>Description of singleton</li>
<li>target : test singleton design pattern</li>
<li><p>@author Jacob<br>*/<br>class singleton {</p>
<p> /<em> 保存单实例 </em>/<br> private static $instance;</p>
<p> /<em> 构造函数声明为private，防止被直接创建对象 </em>/<br> private function __construct() {</p>
<pre><code>echo &quot;singleton 被实例化了&quot;;
</code></pre><p> }</p>
<p> /<em> 单例方法 </em>/<br> public static function get_instance(){</p>
<pre><code>if(!isset(self::$instance)){
    self::$instance = new self();
}
return self::$instance;
</code></pre><p> }</p>
<p> /<em> 阻止用户复制对象实例 </em>/<br> private function __clone() {</p>
<pre><code>trigger_error(&apos;clone is not allowed&apos;,E_USER_ERROR);
</code></pre><p> }</p>
<p> public function test(){</p>
<pre><code>echo(&quot;a singleton call&quot;);
</code></pre><p> }</p>
</li>
</ul>
<p>}<br>/<em> $test = new singleton(); </em>/<br>/* Fatal error: Uncaught Error: Call to private singleton::__construct() from invalid context in D:\designpattern\singleton.php:42<br>Stack trace:</p>
<p>#0 {main}<br>  thrown in D:\designpattern\singleton.php on line 42</p>
<ul>
<li>*/</li>
</ul>
<p>$test = singleton::get_instance();<br>$test = singleton::get_instance();<br>$test-&gt;test();</p>
<p>/<em> $test_newObj = clone $test; </em>/<br>/* singleton 被实例化了a singleton call<br>Fatal error: Uncaught Error: Call to private singleton::__clone() from context ‘’ in D:\designpattern\singleton.php:52<br>Stack trace:</p>
<p>#0 {main}<br>  thrown in D:\designpattern\singleton.php on line 52<br>  */<br>`</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/04/16/blog_理解backlogsomaxconn内核参数/">
  理解backlog/somaxconn内核参数
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/04/16/blog_理解backlogsomaxconn内核参数/"><span class="article-date">
  2019-04-16
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/linux/">linux</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="理解backlog-somaxconn内核参数"><a href="#理解backlog-somaxconn内核参数" class="headerlink" title="理解backlog/somaxconn内核参数"></a>理解backlog/somaxconn内核参数</h1><h2 id="在看上述两个参数之前，我们需要了解一下TCP-SYN-RCVD-ESTABLISHED状态对应的队列"><a href="#在看上述两个参数之前，我们需要了解一下TCP-SYN-RCVD-ESTABLISHED状态对应的队列" class="headerlink" title="在看上述两个参数之前，我们需要了解一下TCP SYN_RCVD,ESTABLISHED状态对应的队列"></a>在看上述两个参数之前，我们需要了解一下TCP SYN_RCVD,ESTABLISHED状态对应的队列</h2><p>1.TCP_RCVD和ESTABLISHED状态对应的队列<br>    TCP建立连接需要三次握手，在客户端想服务器发发起连接时，对于服务器而言，一个完整的连接建立过程，服务器会经历2中TCP状态：SYN_RCVD和ESTABLISHED</p>
<p>对应会维护两个队列：</p>
<ul>
<li>一个存放SYN_RCVD状态的队列（半连接队列）</li>
<li>一个存放ESTABLISHED状态但是还未被accept的连接队列。<br> 如果一个服务器需要处理大量的网络连接并且并发性比较高,这两个队列就显得十分重要了。因为即使服务器的硬件配置非常高，服务端性能很好，但这两个队列非常小，那么经常会出现客户端连不上的现象，因为这两个队列一旦满了以后，很容易丢包或者连接被复位，因此服务器并发访问量高的情况下，这两个队列的长度十分重要。<br>2.半连接队列<br>2.1. 半连接队列长度如何计算<br>半连接队列长度由内核参数tcp_max_syn_backlog决定，当使用SYN Cookie时（就是内核参数net.ipv4.tcp_syncookies = 1）,这个参数无效，即半连接队列长度 = min(backlog,内核参数net.core.somaxconn,内核参数tcp_max_syn_backlog),半连接队列长度肯定小于全连接队列的长度。这个公式实际上规定半连接队列长度不能超过全连接队列的长度。<br>2.2. 半连接满之后的动作<br>首先，全连接满会影响半连接满。全连接满且半连接中有一定数目处于SYN_RCVD状态的连接时，没有必要再继续新的半连接，因为此时全连接已满，此时的动作时直接忽略该连接。<br>半连接满了之后的动作是直接葫忽略（ignore or dropped），此时客户端需要不断的重发SYNC进行重试，重试的参数由tcp_syn_retries决定，该参数默认是5.如果超过客户端设置的超时时间，会报连接超市异常。<br>2.3. syn flood攻击<br>客户端发出SYNC之后，不响应ACK，此时造成半连接队列满，server不能再提供服务，正常的客户端一直报连接超时。为了应对该攻击，有两种办法：</li>
<li>tcp_syncookies<br>不建议该方案，因为违反了TCP规范</li>
<li>其他参数<br>tcp_synack_retries减小重传次数<br>tcp_max_syn_backlog调整半连接队列大小<br>2.4. 如何监控半连接满<br>netstat -s | grep -E “listen|LISTEN”<br>3.全连接队列<br>3.1.全连接队列长度如何计算<br>全连接队列长度 = min(backlog,内核参数 net.core.somaxconn)<br>net.core.somaxconn默认为128<br>net.core.somaxconn 定义了系统级别的全连接队列最大长度，backlog 只是应用层传入的参数，不可能超过内核参数，所以backlog必须小于等于net.core.somaxconn。<br>3.1.1. backlog-应用参数<br>对于Linux而言，基本上任意语言实现的通信框架或服务器程序在构造socket server时，都提供了backlog这个参数，因为在监听端口时，都会调用系统底层API：int listen(int sockfd,int backlog);listen函数中backlog参数的定义如下：<br>Now it specifies the queue length for completely established sockets waiting to be accepted,instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using the tcp_max_syn_backlog sysctl;<br>When syncookies are enabled there is no logical maximum length and this sysctl setting is ignored.<br>if he socket is of AF_INET ,and the backlog argument is greater than the constant SOMAXCONN(129 default),<br>it is silently truncated to SOMAXCONN.<br>backlog 参数描述的是服务器端 TCP ESTABLISHED状态对应的全连接队列长度。<br>3.1.2 net.core.somaxconn-内核参数<br>cat /proc/sys/net/core/somaxconn或者sysctl -a | grep “net.core.somaxconn”线上机器运行结果如下：</li>
</ul>
<p>3.2 查看全连接长度<br>Recv-Q：全连接队列中数据的个数，也是等待被accept的个数<br>Send-Q：全连接队列长度</p>
<p>3.3全连接队满之后的动作<br>1.全连接队满了之后，收到第三次握手的ACK之后首先根据tcp_abort_on_overflow来执行满之后的动作，该参数默认为0.<br>0表示：如果三次握手第三步的时候全连接队列满了那么server扔掉client发过来的ack（在server端认为连接还没有建立起来）<br>1表示：如果全连接队列满了，server发送一个reset包给client，表示丢掉这个握手的过程和这个连接（在server看来连接还未建立）。<br>如果tcp_abort_on_overflow为0，则server直接忽略掉收到的ACK，之后server端不断地重发SYN+ACK。其中tcp_synack_retries参数决定了重试几次才放弃，默认值是5，间隔1s，2s，4s，8s，16s，总共31s，第五次发出后还要等32s才知道第5次也超时了，所以，总共需要31s+32s = 63s,TCP才会把这个连接断开。<br>如果在client上走完第三步，在client看来连接已经建立好了，但server上的对应连接实际没有准备好，这个时候server没有回复，一段时间后，client认为丢包了然后重传包，一直到超时，client报连接异常并主动发fin包断开连接（这个问题也叫client fooling）<br>3.如果tcp_abort_on_overflow为1，则直接响应RST信号，此时客户端报connection reset by peer。<br>3.4.监控全连接队满<br>netstat -s | egrep “listen|LISTEN”<br>ss -ltn Recv-Q &gt; Send-Q<br>4.参数<br>tcp_max_syn_backlog<br>net.core.somaxconn<br>backlog(应用层传入)，java默认为50，freebsd实测为128<br>tcp_synack_retries<br>tcp_abort_on_overflow<br>tcp_syn_retries<br>5.容器中的全连接队列参数<br>tomcat默认短连接，backlog(在tomcat里面属于是Accept count)默认为100<br>nginx默认是 511<br>因为nginx是多进程模式，也就是多个进程都箭筒同一个端口以尽量避免上下文切换来提升性能。<br>打印机631和dns53端口 都是5</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/04/16/linux下ss命令和netstat的区别/">
  linux命令下ss命令和netstat的区别
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/04/16/linux下ss命令和netstat的区别/"><span class="article-date">
  2019-04-16
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/linux/">linux</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="linux下ss命令和netstat命令的区别"><a href="#linux下ss命令和netstat命令的区别" class="headerlink" title="linux下ss命令和netstat命令的区别"></a>linux下ss命令和netstat命令的区别</h1><p>ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。<br>ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。原因如下：<br>1）当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。<br>2）而ss快的秘诀在于它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢（但仍然比 netstat要快）。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/04/14/百度面试经历/">
  百度暑期实习面试经历——20190414
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/04/14/百度面试经历/"><span class="article-date">
  2019-04-14
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/面试经历/">面试经历</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h3 id="面试岗位C-php"><a href="#面试岗位C-php" class="headerlink" title="面试岗位C++/php"></a>面试岗位C++/php</h3><p>面试结果：一面淘汰</p>
<h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><p>1.是否熟悉linux</p>
<p>2.描述一下进程通信</p>
<p>3.描述一下守护进程 除了fork方式还有其他什么方式创建守护进程</p>
<p>4.设计模式 包括哪几种 分别有什么特点</p>
<p>5.平衡二叉树定义，写一个判断平衡二叉树的程序</p>
<p>6.说一下计算机网络轮询方式</p>
<p>7.进程调度算法，描述</p>
<p>8.其他的关于计算机网络地聊了一点，还可以</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/03/06/数组内求和取目标值问题/">
  数组内求和取目标值问题
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/03/06/数组内求和取目标值问题/"><span class="article-date">
  2019-03-06
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/算法/">算法</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，再给一个target，求数组中存在的两个不同元素之和为target的数组下标</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>思路一：无脑遍历，时间复杂度O(n^2)，空间复杂度为O(1)</li>
<li>思路二：使用哈希表，直观体现为java中的hashmap，存入一个值value,并找target-value为键的值是否在hashmap中。<br>时间复杂度为O(n),空间复杂度为O(n)。</li>
</ul>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/01/23/linux_c_c++-头文件及动态链接库加载问题/">
  linux c/c++-头文件及动态链接库加载问题
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/01/23/linux_c_c++-头文件及动态链接库加载问题/"><span class="article-date">
  2019-01-23
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/语言基础/">语言基础</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <ul>
<li>头文件加载<ul>
<li>-I /usr/local/include 表示将/usr/local/include作为第一个寻找头文件的目录，当用到</li>
</ul>
</li>
<li>动态链接库<ul>
<li>-L /usr/local/lib 表示将 /usr/local/lib 目录作为第一个寻找库文件的目录，寻找的顺序是：/usr/local/lib–&gt;/lib–&gt;/usr/lib</li>
<li>-lmemcached表示在上面的lib的路径中寻找libmemcached.so动态库文件（如果gcc编译选项中加入了“-static”表示寻找libmemcached.a静态库文件），程序链接的库名是memcached</li>
<li>链接器ld的选项有 -L，-rpath 和 -rpath-link，看了下 man ld，大致是这个意思：<ul>
<li>-L: “链接”的时候，去找的目录，也就是所有的 -lFOO 选项里的库，都会先从 -L 指定的目录去找，然后是默认的地方。编译时的-L选项并不影响环境变量LDLIBRARYPATH，-L只是指定了程序编译连接时库的路径，并不影响程序执行时库的路径，系统还是会到默认路径下查找该程序所需要的库，如果找不到，还是会报错，类似cannot open shared object file。</li>
<li>-rpath-link：这个也是用于“链接”的时候的，例如你显示指定的需要 FOO.so，但是 FOO.so 本身是需要 BAR.so 的，后者你并没有指定，而是 FOO.so 引用到它，这个时候，会先从 -rpath-link 给的路径里找。</li>
<li>-rpath: “运行”的时候，去找的目录。运行的时候，要找 .so 文件，会从这个选项里指定的地方去找。对于交叉编译，交叉编译链接器需已经配置 –with-sysroot 选项才能起作用。也就是说，-rpath指定的路径会被记录在生成的可执行程序中，用于运行时查找需要加载的动态库。-rpath-link 则只用于链接时查找。</li>
</ul>
</li>
</ul>
</li>
<li>当遇到不同机器相同系统下，链接通过但无法找到加载库时，考虑使用-rpath加链接库路径，援引我的老师的一句话，解释了我为什么遇到相同系统环境，链接库加载情况不同。ldd ./function 查看链接库加载情况。<blockquote>
<p>因为虽然都是FreeBSD-11.2, 但是因为CPU不同是两个重新编译的内核<br>a服务器  是Freebsd-11.2 for X86   因为它不支持gelara数据为同步，所以购买服务器时购买了AMD的服务器， b服务器是Freebsd-11.2 for AMD</p>
</blockquote>
</li>
</ul>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/01/10/剑指offer-滑动窗口求最值/">
  剑指offer-滑动窗口求最值
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/01/10/剑指offer-滑动窗口求最值/"><span class="article-date">
  2019-01-10
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/算法/">算法</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用双向队列，每次从队尾进队一个新数，在新数前面比新数小的或相等的全部出队，得到一个队头始终是最大值的队列，每次进队一个新数后，判断队头的元素是否在窗口中，不在窗口中就出队，每滑动一次窗口，就在结果集中加入新数字。<br>    import java.util.ArrayList;<br>import java.util.Deque;<br>import java.util.concurrent.LinkedBlockingDeque;<br>public class Solution {<br>    public ArrayList<integer> maxInWindows(int [] num, int size)<br>    {<br>        Deque<integer> dq = new LinkedBlockingDeque<integer>();<br>        ArrayList<integer> list = new ArrayList<integer>();<br>        if(num.length == 0 || size &gt; num.length || size &lt;= 0)<br>            return list;<br>        for(int i = 0; i &lt; num.length; i++) {<br>            while(dq.size() &gt; 0 &amp;&amp; num[dq.peekLast()] &lt;= num[i]) dq.pollLast();<br>            while(dq.size() &gt; 0 &amp;&amp; dq.peekFirst() &lt; i-size+1) dq.pollFirst();<br>            dq.offerLast(i);<br>            if(i&gt;=size-1)<br>                list.add(num[dq.peekFirst()]);<br>        }<br>        return list;<br>    }<br>}</integer></integer></integer></integer></integer></p>

        
      </div>
    </div>

  



  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/archives/page/2/">2</a><a class="page-number" href="/blog/archives/page/3/">3</a><a class="page-number" href="/blog/archives/page/4/">4</a><a class="extend next" rel="next" href="/blog/archives/page/2/">Next</a>
  </div>


</div></section>

          <div class="main-footer">
  
    © 2019 Jacob&#39;s blog - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/blog/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/blog/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/blog/PhotoSwipe/photoswipe.js"></script>
  <script src="/blog/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/blog/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/blog/scripts/main.js"></script>

</body>
</html>
