<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    Jacob&#39;s blog
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="Jacob&#39;s blog">
<meta property="og:url" content="/blog/index.html">
<meta property="og:site_name" content="Jacob&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jacob&#39;s blog">


  <link rel="alternative" href="/atom.xml" title="Jacob&#39;s blog" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/blog/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/blog/styles/main.css">






</head>
<body class="monochrome">
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/blog/">Jacob&#39;s blog</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/blog/">Jacob&#39;s blog</a></h1>
    
      <p class="subtitle">
        notebook
      </p>
    
    <div class="info">
      <div class="content">
        
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="/blog/images/cc/about.jpg"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">Category</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/markdown基本用法/">markdown基本用法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/teammates/">teammates</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/数据库基础/">数据库基础</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法/">算法</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/算法笔记/">算法笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/计算机网络/">计算机网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/设计模式/">设计模式</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/语言基础/">语言基础</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/categories/面试经历/">面试经历</a><span class="category-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">Tag</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">Archive</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/">2019</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/">2018</a><span class="archive-list-count">21</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/blog/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/blog/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://fatty.github.io/blog/archives/" title="沈赵" target="_blank" rel="noopener">沈赵</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/Fatty" title="Github" target="_blank" rel="noopener">Github</a>
              </li>
            
          
            
              <li>
                <a href="/blog/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/09/07/高性能MySQL第一章/">
  高性能MySQL第一章
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/09/07/高性能MySQL第一章/"><span class="article-date">
  2019-09-07
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/数据库基础/">数据库基础</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h2 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h2><ul>
<li><p>最上层的服务并不是MySQL独有，大多数基于网络的C/S架构，都相同，比如：认证、连接处理、安全等。</p>
</li>
<li><p>第二层架构MySQL比较有意思的部分，大多数MySQL的核心服务功能都在这一层。包括查询解析、分析、优化、缓存以及所偶的内置函数（例如日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
</li>
<li><p>第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。和GNU/Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得的这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL（InnoDB是个例外，它会解析外键定义，因为MySQL服务器本身并没有实现该功能），不同存储引擎之间也不会相互通信，二只是简单地响应上层服务器请求。</p>
</li>
</ul>
<h3 id="1-1-1-连接管理与安全性"><a href="#1-1-1-连接管理与安全性" class="headerlink" title="1.1.1 连接管理与安全性"></a>1.1.1 连接管理与安全性</h3><ul>
<li><p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或销毁线程（MySQL5.5或者更新版本提供了一个API，支持线程池（Thread-Pooling）插件，可以使用少量线程来服务大量的连接）。</p>
</li>
<li><p>当客户端（应用）连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。如果使用了安全套接字的方式连接，还可使用X.509进行证书认证。一旦客户端连接成功，服务器会继续验证该客户是否有权限制定某个特定的查询的权限。</p>
</li>
</ul>
<h3 id="1-1-2-优化与执行"><a href="#1-1-2-优化与执行" class="headerlink" title="1.1.2 优化与执行"></a>1.1.2 优化与执行</h3><ul>
<li><p>MySQL会解析查询、并创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示（hint）优化器，影响它的决策过程。也可以请求优化解释器（explain）优化过程的哥哥因素。使用户可以知道服务器是如何进行优化决策的，并提供一个参考基准，便于用户重构查询和schema、修改相关配置，是应用尽可能高效运行。</p>
</li>
<li><p>优化器并不关心表使用的是什么存储引擎，但存储引擎对于优化查询是有影响的。优化器会请求存储引擎提供容量和或某个具体操作的开销信息，以及表数据的统计信息等。</p>
</li>
<li><p>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行整个过程，而是直接返回查询缓存中的结果集。</p>
</li>
</ul>
<h2 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h2><p>本章讨论的是在服务器层和存储引擎层做的并发控制。</p>
<h3 id="1-2-1-读写锁"><a href="#1-2-1-读写锁" class="headerlink" title="1.2.1 读写锁"></a>1.2.1 读写锁</h3><p>读锁 就是共享锁</p>
<p>写锁 就是排他锁</p>
<h3 id="1-2-2-锁粒度"><a href="#1-2-2-锁粒度" class="headerlink" title="1.2.2 锁粒度"></a>1.2.2 锁粒度</h3><ul>
<li><p>表锁：会锁定整张表，写锁会阻塞其他用户对该表的所有读写操作。读锁之间不互相阻塞。写锁比读锁有更高优先级，写锁请求可能被插入到读锁请求之前。尽管存储引擎可以管理自己的锁，MySQL本身还是会具有各种各有效的表锁来实现不同的目的。例如服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎本身的锁机制。</p>
</li>
<li><p>行级锁：行级锁可以最大化程度地支持并发处理（同时也带来了最大的锁开销）。在InnoDB和XtraDB，以及其他一些存储引擎实现了行级锁。行级锁只在存储引擎层实现，而在MySQL服务器层没实现。</p>
</li>
</ul>
<h2 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h2><p>事务就是一组原子性的SQL查询，或者说是一个独立的工作单元。ACID表示原子性、一致性、隔离性、持久性</p>
<h3 id="1-3-1-隔离级别"><a href="#1-3-1-隔离级别" class="headerlink" title="1.3.1 隔离级别"></a>1.3.1 隔离级别</h3><p>READ UNCOMMITED（未提交读）</p>
<p>READ COMITTED（提交读）一个事务开始时只能读取到已经提交的事务所做的修改</p>
<p>REPEATABLE READ（可重复读）MySQL的默认事务隔离级别，存在幻读的可能性InnoDB和XtraDB通过多版本并发控制解决幻读。</p>
<p>SERIALIZABLE（可串行化）强制事务串行执行</p>
<h3 id="1-3-2-死锁"><a href="#1-3-2-死锁" class="headerlink" title="1.3.2 死锁"></a>1.3.2 死锁</h3><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。InnoDB目前处理的方式是，将持有最少行级排它锁的事务进行回滚。大多数死锁的解决办法为重新执行因死锁回滚的事务。</p>
<h3 id="1-3-3-事务日志"><a href="#1-3-3-事务日志" class="headerlink" title="1.3.3 事务日志"></a>1.3.3 事务日志</h3><p>使用事务日志，存储引擎只需要在修改表的数据时只需要修改其内存拷贝，再把改修改行为记录到持久在硬盘上的事务日志中，而不是每次都将修改的数据本身持久到磁盘。事务日志才用的追加方式，因此会最少量移动在I/O移动磁头，所以此采用事务日志方式相对来说快得多。目前大部分存储引擎是这样实现的，通常称为预写式日志，修改日志需要写两次磁盘。</p>
<h3 id="1-3-4-MySQL中的事务"><a href="#1-3-4-MySQL中的事务" class="headerlink" title="1.3.4 MySQL中的事务"></a>1.3.4 MySQL中的事务</h3><p>MySQL中提供了两种事务型存储引擎：InnoDB和NDB Cluster。另外还有一些第三方的存储引擎也支持事务，比较知名的有XtraDB和PBXT。</p>
<ul>
<li>自动提交（AUTOCOMMIT）</li>
</ul>
<p>MySQL默认采用自动提交模式。也就是说，如果不是显式地开始一个事务。在当前连接中可以设置AUTOCOMMIT变量来启用或禁用自动提交模式：</p>
<p><code>SHOW VARIABLES LIKE &#39;AUTOCOMMIT&#39;;</code></p>
<p><code>SET AUTOCOMMIT = 1;</code></p>
<p>AUTOCOMMIT对于非事务型的存储引擎无效。当AUTOCOMMIT为0时，所有查询都是在一个事务中，直到显式地执行COMMIT提交或ROLLBACK回滚，该事务结束同时又开启了一个新事务。另外还有一些数据定义语言（DDL）中，如果会导致大量数据改变的操作比如ALTER 或 LOCK 会在执行前强制提交上一个事务。MySQL可以通过执行SET TRANSACTION ISOLATION LEVEL来设置隔离级别，新的隔离级别会在下一个事务开始时生效。可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别：</p>
<p><code>SET SESSION TRANSCATION ISOLATION LEVEL READ COMMITTED</code></p>
<p>MySQL能够识别所有的4个ANSI级别，InnoDB引擎也支持所有的隔离级别。</p>
<ul>
<li>在事务中混合使用存储引擎</li>
</ul>
<p>MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一事务中，使用多种存储引擎也是不可靠的。</p>
<ul>
<li>隐式和显示锁定</li>
</ul>
<p>InnoDB才用的是两阶段多订协议（TWO-Phase Locking Protocol）。在食物执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或 ROLLBACK 时才会释放，并且所有的锁都在同一时刻被释放。前面描述的锁都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。</p>
<p>另外InnoDB也支持通过特定的语句进行显式锁定，这些语句不属于SQL的范畴（这些锁提示经常被滥用，实际上应当尽量避免使用。）</p>
<p><code>SELECT ... LOCK IN SHARE MODE</code></p>
<p><code>SELECT ... FOR UPDATE</code></p>
<p>MySQL也支持LOCK TABLES和UNLOCK TABLES语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务处理。如果应用需要用到事务，还是应选择事务型存储引擎。</p>
<p>经常可以发现，应用已经从MyISAM转换到InnoDB，但还是显式地使用LOCK TABLES语句，这很影响性能，实际上InnoDB的行级锁工作得更好。（书中建议，除了禁用了AUTOCOMMIT可以使用LOCK TABLES外，其他任何时候都不要显式地执行LOCK TABLES,不管使用的是什么存储引擎）</p>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于性能提升的考虑，他们一般都同时实现了多版本并发控制（MVCC）。</p>
<p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现的机制不同，但大都实现了非阻塞的读操作，写操作也只是锁定了必要的行。</p>
<p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说不需要执行多长时间，每个事务看到的数据是一致的。根据事务开始时间的不同，每个事务对同一张表、同一时刻看到的数据可能不同。</p>
<p>不同的存储引擎的MVCC的实现是不同的，典型的有乐观（optimistic）并发控制和悲观（positive）并发控制。</p>
<p>InnoDB的简化版MVCC：</p>
<p>InnoDB的MVCC是通过记录后面两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号就会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>在REPEATABLE READ隔离级别下，MVCC具体是如何操作的：</p>
<p>SELECT:<br>InnoDB会根据以下两个条件检查每行记录：<br>a. InnoDB之查版本早于当前事务版本的数据行（也就是行的系统版本号 &lt;= 事务的版本号），这样可以保证事务读取到的行，要么是在事务开始前已经存在，要么是事务自身插入或者修改过的。b. 行的删除版本要么未定义要么大于当前事务版本号。这样可以确定事务读取到的行在事务开始之前未被删除。</p>
<p>INSERT:<br>InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p>DELETE:<br>InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p>UPDATE:<br>InnoDB为插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统的版本号到原来的行作为删除标识。</p>
<p>保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能好，符合标准。不足之处是多了两个字段，增加了维护成本，需要做更多检查工作。</p>
<p>MVCC只在REPEATABLE READ 和 READ COMMITED 两个隔离级别工作。READ UNCOMMIED 总会读取到最新的行 和 SERIALIZABLE 对所有读取的行都上锁不支持MVCC</p>
<h2 id="1-5-MySQL的存储引擎"><a href="#1-5-MySQL的存储引擎" class="headerlink" title="1.5 MySQL的存储引擎"></a>1.5 MySQL的存储引擎</h2><h3 id="1-5-1-InnoDB存储引擎"><a href="#1-5-1-InnoDB存储引擎" class="headerlink" title="1.5.1 InnoDB存储引擎"></a>1.5.1 InnoDB存储引擎</h3><p>InnoDB是MySQL的默认存储引擎，也是最重要，使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分是正常提交的，很少会回滚。InnoDB的性能和自动崩溃恢复特性，使它在非事务型存储的需求中也很流行。</p>
<ul>
<li><p>InnoDB预览：InnoDB的数据存储在表空间（TableSpace）中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件构成。InnoDB可以将每个表的数据和索引存储在单独的文件中。</p>
</li>
<li><p>InnoDB 采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别为可重复读（REPEATABLE READ），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>
</li>
<li><p>InnoDB是基于聚集簇索引建立的。InnoDB的索引结构与其他存储引擎有很大不同，聚集簇索引对主键索查询有很高的性能，它的非主键索引必须包含主键列，因此主键列很大的话，其他索引也会很大，因此，主键应尽可能地小。</p>
</li>
<li><p>InnoDB 做了很多优化，包括从磁盘读取数据时采用的可预测性读，能够在内存中创建HASH索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p>
</li>
<li><p>InnoDB的行为很复杂，不易理解。建议阅读“InnoDB的事务模型和锁”。</p>
</li>
<li><p>作为事务型的存储引擎，InnoDB通过一些机制和工作工具真正的热备份，MySQL Enterprise Backup 和 XtraBackup都可以做到这一点。</p>
</li>
</ul>
<h3 id="1-5-2-MyISAM存储引擎"><a href="#1-5-2-MyISAM存储引擎" class="headerlink" title="1.5.2 MyISAM存储引擎"></a>1.5.2 MyISAM存储引擎</h3><p>MyISAM是默认的存储引擎，提供了大量的特性，全文索引、压缩、空间函数（GIS）等，不支持行级锁和事务。</p>
<h3 id="1-5-3-内建的其它存储引擎"><a href="#1-5-3-内建的其它存储引擎" class="headerlink" title="1.5.3 内建的其它存储引擎"></a>1.5.3 内建的其它存储引擎</h3><ul>
<li><p>Archive存储引擎：针对高速插入和压缩做了简单优化的引擎</p>
</li>
<li><p>BlackHole不存储只有引擎会记录日志，被用作特殊的复制架构和日志审核</p>
</li>
<li><p>CSV引擎可以作为一种数据交换的机制</p>
</li>
<li><p>Federated引擎是访问其他MySQL 服务器的代理</p>
</li>
<li><p>Memory表保存在内存中，和临时表不同，哈希索引查找快，表级锁，并发写入不好，每行长度固定。</p>
</li>
<li><p>Merge引擎，多个MyISAM的合并，已被弃用。</p>
</li>
<li><p>NDB引擎，MySQL服务器，NDB集群存储引擎，分布式的、SHARE-NOTHING的、容灾的、高可用的NDB数据库的组合，被称为MySQL集群。</p>
</li>
</ul>
<h3 id="1-5-4-第三方存储引擎"><a href="#1-5-4-第三方存储引擎" class="headerlink" title="1.5.4 第三方存储引擎"></a>1.5.4 第三方存储引擎</h3><ul>
<li><p>OLTP类</p>
</li>
<li><p>面向列的存储引擎</p>
</li>
<li><p>社区存储引擎</p>
</li>
</ul>
<h3 id="1-5-5-选择合适的引擎"><a href="#1-5-5-选择合适的引擎" class="headerlink" title="1.5.5 选择合适的引擎"></a>1.5.5 选择合适的引擎</h3><h3 id="1-5-6-转换表的引擎"><a href="#1-5-6-转换表的引擎" class="headerlink" title="1.5.6 转换表的引擎"></a>1.5.6 转换表的引擎</h3><p><code>ALTER TABLE MYTABLE ENGINE = InnoDB</code></p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/09/04/sql是如何执行的/">
  SQL是如何执行的
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/09/04/sql是如何执行的/"><span class="article-date">
  2019-09-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/数据库基础/">数据库基础</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <ul>
<li>SQL是声明式语言，在不同数据库中SQL的实现方式还是有区别的。<h1 id="ORACLE中的SQL是如何执行的"><a href="#ORACLE中的SQL是如何执行的" class="headerlink" title="ORACLE中的SQL是如何执行的"></a>ORACLE中的SQL是如何执行的</h1>在ORACLE中，SQL从输入到执行，经历了如下的过程：</li>
<li>语法检查：检查SQL拼写是否正确</li>
<li>语义检查：检查SQL中的访问对象，是否正确，是否访问了不存在的对象或列</li>
<li>权限检查：检查用户是否具备访问该数据对象的权限</li>
<li>共享池检查：共享池（shared pool）是一块内存池，最主要的作用是缓存SQL语句和该语句执行的计划。ORACLE通过检查，共享池中是否存在SQL语句计划来决定进行软解析还是硬解析。</li>
<li>优化器：优化器中就是要进行硬解析，也就是决定怎么做，创建解析树，生成执行计划。</li>
<li>执行：当有了解析树和执行计划后，就知道了SQL该怎么执行，这样就可以在执行器中执行语句了。</li>
</ul>
<h2 id="硬解析和软解析"><a href="#硬解析和软解析" class="headerlink" title="硬解析和软解析"></a>硬解析和软解析</h2><ul>
<li>（软解析就是根据语句生成的HASH值在库缓存（Library Cache）中查找是否存在SQL语句的执行计划，如果存在SQL的执行计划，就直接进入执行器的环节。） </li>
<li>（硬解析就是根据HASH值没有找到SQL语句和执行计划，ORACLE创建解析树进行解析，并生成执行计划，进入优化器）<h2 id="共享池"><a href="#共享池" class="headerlink" title="共享池"></a>共享池</h2></li>
<li>共享池是ORACLE中的术语，包括了库缓存，数据字典缓冲区等。我们上面已经讲到了库缓存区，它主要缓存SQL语句和执行计划。而数据字典缓冲区存储的是ORACLE中的对象定义，比如表、视图、索引等对象。当对SQL语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。 </li>
<li>库缓存这一步骤，决定了SQL语句是否需要进行硬解析。为了提升SQL的执行效率，我们应该尽量避免硬解析，因为在SQL执行的过程中，创建解析树、生成执行计划是十分消耗资源的。<h2 id="避免硬解析"><a href="#避免硬解析" class="headerlink" title="避免硬解析"></a>避免硬解析</h2></li>
<li>在ORACLE中绑定变量是它的一大特色。绑定变量就是在SQL语句中使用变量，通过不同的变量取值来改变SQL的执行结果。这样做的好处是提升软解析的可能性，不足之处是可能会存在生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</li>
</ul>
<p>优化前</p>
<figure class="highlight plain"><figcaption><span>player_name from palyer where player_id </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优化后</span><br><span class="line"></span><br><span class="line">``` select player_name from player where palyer_id = :player_id</span><br></pre></td></tr></table></figure>
<h1 id="MYSQL中的SQL是如何执行的"><a href="#MYSQL中的SQL是如何执行的" class="headerlink" title="MYSQL中的SQL是如何执行的"></a>MYSQL中的SQL是如何执行的</h1><h2 id="MYSQL的体系结构"><a href="#MYSQL的体系结构" class="headerlink" title="MYSQL的体系结构"></a>MYSQL的体系结构</h2><ul>
<li>首先MySQL是典型的C/S架构，即Client/Server架构，服务器端的程序使用mysqld</li>
<li>MySQL由三层构成：</li>
</ul>
<ol>
<li><p>连接层：客户端和服务器端建立连接，客户端发送SQL至服务器端</p>
</li>
<li><p>SQL层：处理SQL语句，从解析到执行</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SQL层与数据文件的存储方式无关：</span><br><span class="line"></span><br><span class="line">当查询缓存中有这条语句时：</span><br><span class="line"></span><br><span class="line">SQL语句-&gt;查询缓存-&gt;执行器</span><br><span class="line"></span><br><span class="line">没有时：</span><br><span class="line"></span><br><span class="line">SQL语句-&gt;解析器-&gt;优化器-&gt;执行器</span><br></pre></td></tr></table></figure>
<p>查询缓存:Server如果在缓存中发现了这条SQL语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为缓存查询往往效率不高，在Mysql8.0后被抛弃。</p>
<p>解析器：在解析器中对SQL语句进行语法分析、语义分析。</p>
<p>优化器：在优化器中会确定SQL语句的执行路径，比如是全表检索，还是根据索引来检索等。</p>
<p>执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行SQL查询并返回结果。在MySQL8.0以下的版本中，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<ol start="3">
<li>存储引擎层：与数据文件打交道，负责数据的存储和读取。</li>
</ol>
<p>与ORACLE不同的是，MySQL的存储引擎采用了插件的形式，每个存储引擎都面向一种特定的数据库应用环境。同时开源的MySQL还允许开发人员设置自己的存储引擎，下面是一些常见的存储引擎：</p>
<p>InnoDB存储引擎：它是MySQL5.5版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。</p>
<p>MyISAM存储引擎：在MySQL5.5版本之前是默认的存储引擎，不支持事务及外键，速度快，占用资源少。</p>
<p>Memory存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果Mysqld进程崩溃，会导致所有数据丢失，因此，只有当存储临时数据时才会采用Memory存储引擎。</p>
<p>NDB存储引擎：也叫作NDB Cluster存储引擎，主要用于MySQL Cluster分布式集群环境，类似于ORACLE的RAC集群。</p>
<p>Archive存储引擎：他有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，通常被作为仓库。</p>
<p>MySQL的强大之处在于，不同表之间可以采用不同的存储引擎，因此面对不同数据情况时，可根据数据需求选择存储引擎。</p>
<h2 id="如何在SQL中对一条SQL语句的执行时间进行分"><a href="#如何在SQL中对一条SQL语句的执行时间进行分" class="headerlink" title="如何在SQL中对一条SQL语句的执行时间进行分"></a>如何在SQL中对一条SQL语句的执行时间进行分</h2><p>看一下profiling是否开启，开启它可以让MySQL收集在SQL执行时所使用的资源情况</p>
<figure class="highlight plain"><figcaption><span>@@profiling ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">profiling=0 代表关闭，需要设置为1：</span><br><span class="line"></span><br><span class="line">``` set profiling=1</span><br></pre></td></tr></table></figure>
<p>执行一条语句后 执行命令</p>
<p><code>show profile</code></p>
<p>可查看执行时间。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/08/16/一致性hash/">
  一致性hash
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/08/16/一致性hash/"><span class="article-date">
  2019-08-16
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/算法笔记/">算法笔记</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">面试必备：什么是一致性Hash算法？ - 后知后觉的文章 - 知乎</span><br><span class="line">https://zhuanlan.zhihu.com/p/34985026</span><br></pre></td></tr></table></figure>
<h2 id="Redis集群的使用"><a href="#Redis集群的使用" class="headerlink" title="Redis集群的使用"></a>Redis集群的使用</h2><p>在使用Redis集群的时候，为了保证Redis的高可用性，提高Redis读写性能，最简单的方式会做主从复制，组成Master-Master或Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据的主从复制和读写分离。如下图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD   </span><br><span class="line">    写请求--&gt;Master</span><br><span class="line">    Master--&gt;Slave1</span><br><span class="line">    Master--&gt;Slave2</span><br><span class="line">    读请求--&gt;Slave1</span><br><span class="line">    读请求--&gt;Slave2</span><br></pre></td></tr></table></figure>
<p>当数据量很大的时候就要对数据库进行分库分表，Redis也如。录入有2000w条数据，我们可以部署8台缓存服务器，每台500w数据，并进行主从复制，得到4组主从模式的缓存服务组。</p>
<p>由于规则是随机的，我们的一条数据可能存在于任意服务器上，我们使用类似分库分表的规则按照Hash、取模、按类别、按照某一字段值等等常见的规则取值，此时，我们采用hash的方式。</p>
<h2 id="为Redis集群使用Hash"><a href="#为Redis集群使用Hash" class="headerlink" title="为Redis集群使用Hash"></a>为Redis集群使用Hash</h2><p>由于我们按照Hash规则进行将资源定位到特殊服务器，因此可以大大提升服务性能，不必遍历所有服务器组。</p>
<h2 id="使用Hash的问题"><a href="#使用Hash的问题" class="headerlink" title="使用Hash的问题"></a>使用Hash的问题</h2><p>上述方式虽然提升了性能，我们不再需要对Redis服务器组进行遍历，但是当服务器数量变动时候，所有缓存位置都将发生改变。</p>
<p>当有4组服务器组时</p>
<p>loc = hash(资源) % 4 = 2</p>
<p>当扩充到7台服务器组以后</p>
<p>loc = hash(资源) % 7 = ?</p>
<p>换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据。</p>
<p>为了解决这个问题，提出了一致性哈希算法。</p>
<h2 id="一致性Hash是什么"><a href="#一致性Hash是什么" class="headerlink" title="一致性Hash是什么"></a>一致性Hash是什么</h2><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），N台服务器的地址可采用计算公式表示ip(i)表示第i台服务器的ip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc(i) = hash(ip(i))</span><br></pre></td></tr></table></figure></p>
<p>按照规则，N台服务器的地址在一个环上，整个空间按照顺时针方向组织。正上方的点代表0，以此类推，到2^32-1可以表示为环上的地址。</p>
<p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</p>
<p>根据一致性Hash算法，地址0~loc(i)的资源均存储到服务器i上。</p>
<h2 id="一致性Hash算法的容错性和可扩展性"><a href="#一致性Hash算法的容错性和可扩展性" class="headerlink" title="一致性Hash算法的容错性和可扩展性"></a>一致性Hash算法的容错性和可扩展性</h2><p>如果当服务器i宕机，受影响的数据只有地址从loc(i-1)+1到loc(i)-1的数据。</p>
<p>当加入一台新服务器x到i-1和i之间，此时，受影响的数据只有loc(i-1)+1到loc(x)的数据。</p>
<p>因此，一致性hash对于节点的增减都只会重定位一小部分环空间数据，具有较好的容错性和扩展性。</p>
<h2 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h2><p>一致性Hash算法在节点太少时，节点在换上分布不均匀，会造成大部分环上数据被缓存在某一台服务器上（也就是数据倾斜）。</p>
<p>此时，为了解决这种数据倾斜问，一致性Hash算法，引入了虚拟节点机制，即，为一个真实节点计算出多个虚拟节点，这样有效推动环上数据，尽量均匀分布到每个真实节点。</p>
<h2 id="值得注意的是Redis采用的不是一致性Hash"><a href="#值得注意的是Redis采用的不是一致性Hash" class="headerlink" title="值得注意的是Redis采用的不是一致性Hash"></a>值得注意的是Redis采用的不是一致性Hash</h2><p>Redis采用的算法为Hash Slot</p>
<p>redis cluster 有固定的 16384 个 hash slot，对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。</p>
<p>redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 hash tag 来实现。</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/17/TCP传输机制/">
  TCP传输机制
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/17/TCP传输机制/"><span class="article-date">
  2019-05-17
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/计算机网络/">计算机网络</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <ul>
<li><p>超时重传</p>
<p>  超时重传机制用来保证TCP传输可靠性。每次发送数据包时，发送的数据包都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</p>
</li>
<li><p>快速重传</p>
<p>  接收数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文，如果发送端连续收到相同标号的ack包，会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等超时，然后触发重传；快速重传是接收端主动告诉发送端数据没收到，然后触发发送端重传。</p>
</li>
<li><p>流量控制</p>
<p>  TCP滑动窗口流量控制。TCP头里有个字段叫window也叫advertised-window，这个字段主要是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口可以提高TCP传输效率的一种机制。</p>
</li>
<li><p>拥塞控制</p>
<p>  滑动窗口用来做流量控制。流量控制只关注发送端和接收端自身的状况，而没有考虑整个网络地通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某一时刻网络上的延时突然增加，那么，TCP对于这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断的放大。试想一下，如果一个网络内有成千上万的TCP连接都如此，那么会形成网络风暴，为此TCP引入拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。</p>
<p>  慢启动</p>
<p>  TCP 在连接过程中三次握手完成后，开始传数据，并不是一开始向网络通道中发送大量的数据包，这样容易导致网络中缓存空间耗尽，从而发生拥塞；而是根据cwnd的大小逐步增加发送的数据量，cwnd初始化为1个最大报文段（MSS）大小（可配置成不是一个MSS）；每个报文段被确认cwnd大小指数增长。</p>
<p>  开始-&gt;cwnd = 1 ；<br>  1个RTT后 -&gt; cwnd = 2 <em> 1 = 2；<br>  2个RTT后 -&gt; cwnd = 2 </em> 2 = 4；<br>  3个RTT后 -&gt; cwnd = 4 * 2 = 8；</p>
<p>  拥塞避免</p>
<p>  cwnd不能一直这样无限增长下去，一定要某个限制。TCP使用了一个叫慢启动门限（ssthresh）的变量，一旦cwnd&gt;=ssthresh（大多数TCP实现，通常为65536），慢启动过程结束后，拥塞避免阶段开始：cwnd不在指数级上升，当窗口中所有报文都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，慢慢调整到最佳值。非ECN的环境下的拥塞判断，发送方RTO超时，重传了一个报文段；</p>
<p>  1 把sshtresh降到cwnd的一般<br>  2 把cwnd重新设置为1<br>  3 重新进入慢启动过程 </p>
<p>  快速重传</p>
<p>  TCO收到重复三次ACK时会认为重传队列中的对一个报文段被网络丢弃，但由于收到的重复三次ACK，则认为该报文段的后三个报文段都已经被接收到，则不等待重传定时器超时，直接重发重传队列中的第一个报文段。</p>
<p>  1 把ssthresh设置为cwnd的一半<br>  2 把cwnd再设置为ssthresh的值（具体实现有些为ssthresh+3）<br>  3 重新进入拥塞避免阶段</p>
<p>  快速恢复</p>
<p>  快速恢复的数据包守恒原则，即同一个时刻在网络中的数据包爽恒定，旧数据离开后，才向网络中发哦少年宫新数据包。如果发送方收到一个重复的ACK，TCP的ACK机制就表明有一个数据包离开，此时cwnd加1.</p>
<p>  1 当收到三个重复的ACK时，把sstresh设置为cwnd的一半，把cwnd设置为sstresh的值加3，然后重传丢失的报文段，加3表明收到三个重复的ACK，表明有三个旧的数据包离开了网络。<br>  2 再收到重复的ACK时，拥塞窗口增加1<br>  3 当收到新的数据包ACK时，把cwnd设置为第一步中的ssthresh的值。原因是该ACK确认了新的数据，说明从重复ACK时的数据都已经收到，该恢复过程已经结束，可以回到恢复之前的状态了，也再次进入拥塞避免状态。</p>
</li>
</ul>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/设计模式-适配器模式/">
  适配器模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/设计模式-适配器模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将各种截然不同的函数接口封装成统一的API。 </p>
<p>例如：PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。</p>
<p>首先定义一个接口(有几个方法，以及相应的参数)。然后，有几种不同的情况，就写几个类实现该接口。将完成相似功能的函数，统一成一致的方法。</p>
<pre><code>&lt;?php
</code></pre><p>interface IDatabase<br>{<br>    function connect($host, $user, $passwd, $dbname);<br>    function query($sql);<br>    function close();<br>}<br>class MySQL implements IDatabase<br>{<br>    protected $conn;<br>    function connect($host, $user, $passwd, $dbname)<br>    {<br>        $conn = mysql_connect($host, $user, $passwd);<br>        mysql_select_db($dbname, $conn);<br>        $this-&gt;conn = $conn;<br>    }</p>
<pre><code>function query($sql)
{
    $res = mysql_query($sql, $this-&gt;conn);
    return $res;
}

function close()
{
    mysql_close($this-&gt;conn);
}
</code></pre><p>}<br>class MySQLi implements IDatabase<br>{<br>    protected $conn;</p>
<pre><code>function connect($host, $user, $passwd, $dbname)
{
    $conn = mysqli_connect($host, $user, $passwd, $dbname);
    $this-&gt;conn = $conn;
}

function query($sql)
{
    return mysqli_query($this-&gt;conn, $sql);
}

function close()
{
    mysqli_close($this-&gt;conn);
}
</code></pre><p>}</p>
<p>class PDO1 implements IDatabase<br>{<br>    protected $conn;<br>    function connect($host, $user, $passwd, $dbname)<br>    {<br>        $conn = new \PDO(“mysql:host=$host;dbname=$dbname”, $user, $passwd);<br>        $this-&gt;conn = $conn;<br>    }</p>
<pre><code>function query($sql)
{
    return $this-&gt;conn-&gt;query($sql);
}

function close()
{
    unset($this-&gt;conn);
}
</code></pre><p>}<br>$db = new PDO1();<br>$db-&gt;connect(‘127.0.0.1’, ‘root’, ‘root’, ‘test’);<br>$db-&gt;query(‘show databases’);<br>$db-&gt;close();</p>
<p>$db = MySQLi ();<br>$db-&gt;connect(‘127.0.0.1’, ‘root’, ‘root’, ‘test’);<br>$db-&gt;query(‘show databases’);<br>$db-&gt;close();</p>
<p>$db = MySQl();<br>$db-&gt;connect(‘127.0.0.1’, ‘root’, ‘root’, ‘test’);<br>$db-&gt;query(‘show databases’);<br>$db-&gt;close();</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/创建模式/">
  建造者模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/创建模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式主要用于创建复杂对象，将复杂对象的表示与构造分离。</p>
<p>例子：<br>    &lt;?php<br>/**</p>
<ul>
<li></li>
<li>产品本身<br>*/<br>class Product {<br> private $_parts;<br> public function __construct() { $this-&gt;_parts = array(); }<br> public function add($part) { return array_push($this-&gt;_parts, $part); }<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>建造者抽象类<br><em>
</em>/<br>abstract class Builder {<br> public abstract function buildPart1();<br> public abstract function buildPart2();<br> public abstract function getResult();<br>}</li>
</ul>
<p>/**</p>
<ul>
<li></li>
<li>具体建造者</li>
<li>实现其具体方法<br>*/<br>class ConcreteBuilder extends Builder {<br> private $_product;<br> public function __construct() { $this-&gt;_product = new Product(); }<br> public function buildPart1() { $this-&gt;_product-&gt;add(“Part1”); }<br> public function buildPart2() { $this-&gt;_product-&gt;add(“Part2”); }<br> public function getResult() { return $this-&gt;_product; }<br>}<br>/**<ul>
<li><em>导演者
</em>/<br>class Director {<br>public function __construct(Builder $builder) {<br>   $builder-&gt;buildPart1();//导演指挥具体建造者生产产品<br>   $builder-&gt;buildPart2();<br>}<br>}</li>
</ul>
</li>
</ul>
<p>// client<br>$buidler = new ConcreteBuilder();<br>$director = new Director($buidler);<br>$product = $buidler-&gt;getResult();<br>echo “<pre>“;<br>var_dump($product);<br>echo “</pre>“;<br>/<em>输出： object(Product)#2 (1) {<br>[“_parts”:”Product”:private]=&gt;<br>array(2) {<br>    [0]=&gt;string(5) “Part1”<br>    [1]=&gt;string(5) “Part2”<br>}<br>} </em>/<br>?&gt;</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/设计模式-简单工厂模式/">
  简单工厂模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/设计模式-简单工厂模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>简单工厂模式属于创建型模式，又叫做静态工厂方法模式，单不属于23中GOF设计模式之一。简单工厂模式是由一个工厂决定创建出哪一种产品类的实例，可以理解为不同工厂模式的一个特殊实现。</p>
<ul>
<li>优点：根据外界给定的信息决定究竟应该创建哪个具体类的对象，明确区分了各自的职责和权力，有利于整个软件提结构的优化。</li>
<li>缺点：很明显工厂类集中了所有实例的创建逻辑，容易违反GRASPR的高内聚的责任分配原则。</li>
<li>抽象基类：类中定义一些方法，用以在子类中实现。</li>
<li>继承自抽象基类的子类：实现基类中的抽象方法。</li>
<li>工厂类：用以实例化所有对应的子类。</li>
<li>实例代码：<br>  class SimpleFactoryPattern {<br>  public static function createObj($op){<pre><code>switch ($op){
    case &apos;+&apos; :
        return new OperationAdd();
        break;
    case &apos;-&apos; :
        return new OperationSub();
        break;
    case &apos;*&apos; :
        return new OperationMul();
        break;
    case &apos;/&apos; :
        return new OperationDivide();
    default :
        break;
}
</code></pre>  }<br>}<br>/<em> 抽象类 </em>/<br>abstract class Operation{<br>  abstract public function getValue($num1,$num2);<br>}</li>
</ul>
<p>class OperationAdd extends Operation {<br>    public function getValue($num1, $num2) {<br>        return $num1 + $num2;<br>    }<br>}</p>
<p>class OperationSub extends Operation {<br>    public function getValue($num1, $num2) {<br>        return $num1 - $num2;<br>    }<br>}</p>
<p>class OperationMul extends Operation {<br>    public function getValue($num1, $num2) {<br>        return $num1 * $num2;<br>    }<br>}</p>
<p>class OperationDivide extends Operation {<br>    public function getValue($num1, $num2) {<br>        try {<br>            if($num2 == 0){<br>                throw new Exception(“除数不能为0”);<br>            }else{<br>                return $num1 / $num2;<br>            }<br>        } catch (Exception $exc) {<br>            echo “error：”.$exc-&gt;getTraceAsString();<br>        }<br>    }<br>}</p>
<p>$test = SimpleFactoryPattern::createObj(‘/‘);<br>$result = $test-&gt;getValue(10, 1);<br>echo $result;</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/05/04/设计模式-单例模式/">
  单例模式
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/05/04/设计模式-单例模式/"><span class="article-date">
  2019-05-04
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/设计模式/">设计模式</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><ul>
<li>单例模式，作为对象的创建模式，单例模式确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</li>
<li>特点</li>
</ul>
<ol>
<li>一个类只能有一个实例；</li>
<li>必须自行创建这个实例；</li>
<li>必须向整个系统提供这个实例；</li>
</ol>
<ul>
<li>为什么使用单模式？</li>
<li>用于数据库应用时，可以避免大量的new操作消耗资源，减少数据库连接。</li>
<li>如果系统需要有一个类来全局控制某些配置信息时，那么单例模式可以很方便的实现。</li>
<li>在页面请求中，便于调试，因为所有代码都在一个类中，可以在类中设置钩子，从而有效避免到处var_dump,echo。</li>
<li>例子</li>
<li>`&lt;?php</li>
</ul>
<p>/**</p>
<ul>
<li>Description of singleton</li>
<li>target : test singleton design pattern</li>
<li><p>@author Jacob<br>*/<br>class singleton {</p>
<p> /<em> 保存单实例 </em>/<br> private static $instance;</p>
<p> /<em> 构造函数声明为private，防止被直接创建对象 </em>/<br> private function __construct() {</p>
<pre><code>echo &quot;singleton 被实例化了&quot;;
</code></pre><p> }</p>
<p> /<em> 单例方法 </em>/<br> public static function get_instance(){</p>
<pre><code>if(!isset(self::$instance)){
    self::$instance = new self();
}
return self::$instance;
</code></pre><p> }</p>
<p> /<em> 阻止用户复制对象实例 </em>/<br> private function __clone() {</p>
<pre><code>trigger_error(&apos;clone is not allowed&apos;,E_USER_ERROR);
</code></pre><p> }</p>
<p> public function test(){</p>
<pre><code>echo(&quot;a singleton call&quot;);
</code></pre><p> }</p>
</li>
</ul>
<p>}<br>/<em> $test = new singleton(); </em>/<br>/* Fatal error: Uncaught Error: Call to private singleton::__construct() from invalid context in D:\designpattern\singleton.php:42<br>Stack trace:</p>
<p>#0 {main}<br>  thrown in D:\designpattern\singleton.php on line 42</p>
<ul>
<li>*/</li>
</ul>
<p>$test = singleton::get_instance();<br>$test = singleton::get_instance();<br>$test-&gt;test();</p>
<p>/<em> $test_newObj = clone $test; </em>/<br>/* singleton 被实例化了a singleton call<br>Fatal error: Uncaught Error: Call to private singleton::__clone() from context ‘’ in D:\designpattern\singleton.php:52<br>Stack trace:</p>
<p>#0 {main}<br>  thrown in D:\designpattern\singleton.php on line 52<br>  */<br>`</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/04/16/blog_理解backlogsomaxconn内核参数/">
  理解backlog/somaxconn内核参数
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/04/16/blog_理解backlogsomaxconn内核参数/"><span class="article-date">
  2019-04-16
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/linux/">linux</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="理解backlog-somaxconn内核参数"><a href="#理解backlog-somaxconn内核参数" class="headerlink" title="理解backlog/somaxconn内核参数"></a>理解backlog/somaxconn内核参数</h1><h2 id="在看上述两个参数之前，我们需要了解一下TCP-SYN-RCVD-ESTABLISHED状态对应的队列"><a href="#在看上述两个参数之前，我们需要了解一下TCP-SYN-RCVD-ESTABLISHED状态对应的队列" class="headerlink" title="在看上述两个参数之前，我们需要了解一下TCP SYN_RCVD,ESTABLISHED状态对应的队列"></a>在看上述两个参数之前，我们需要了解一下TCP SYN_RCVD,ESTABLISHED状态对应的队列</h2><p>1.TCP_RCVD和ESTABLISHED状态对应的队列<br>    TCP建立连接需要三次握手，在客户端想服务器发发起连接时，对于服务器而言，一个完整的连接建立过程，服务器会经历2中TCP状态：SYN_RCVD和ESTABLISHED</p>
<p>对应会维护两个队列：</p>
<ul>
<li>一个存放SYN_RCVD状态的队列（半连接队列）</li>
<li>一个存放ESTABLISHED状态但是还未被accept的连接队列。<br> 如果一个服务器需要处理大量的网络连接并且并发性比较高,这两个队列就显得十分重要了。因为即使服务器的硬件配置非常高，服务端性能很好，但这两个队列非常小，那么经常会出现客户端连不上的现象，因为这两个队列一旦满了以后，很容易丢包或者连接被复位，因此服务器并发访问量高的情况下，这两个队列的长度十分重要。<br>2.半连接队列<br>2.1. 半连接队列长度如何计算<br>半连接队列长度由内核参数tcp_max_syn_backlog决定，当使用SYN Cookie时（就是内核参数net.ipv4.tcp_syncookies = 1）,这个参数无效，即半连接队列长度 = min(backlog,内核参数net.core.somaxconn,内核参数tcp_max_syn_backlog),半连接队列长度肯定小于全连接队列的长度。这个公式实际上规定半连接队列长度不能超过全连接队列的长度。<br>2.2. 半连接满之后的动作<br>首先，全连接满会影响半连接满。全连接满且半连接中有一定数目处于SYN_RCVD状态的连接时，没有必要再继续新的半连接，因为此时全连接已满，此时的动作时直接忽略该连接。<br>半连接满了之后的动作是直接葫忽略（ignore or dropped），此时客户端需要不断的重发SYNC进行重试，重试的参数由tcp_syn_retries决定，该参数默认是5.如果超过客户端设置的超时时间，会报连接超市异常。<br>2.3. syn flood攻击<br>客户端发出SYNC之后，不响应ACK，此时造成半连接队列满，server不能再提供服务，正常的客户端一直报连接超时。为了应对该攻击，有两种办法：</li>
<li>tcp_syncookies<br>不建议该方案，因为违反了TCP规范</li>
<li>其他参数<br>tcp_synack_retries减小重传次数<br>tcp_max_syn_backlog调整半连接队列大小<br>2.4. 如何监控半连接满<br>netstat -s | grep -E “listen|LISTEN”<br>3.全连接队列<br>3.1.全连接队列长度如何计算<br>全连接队列长度 = min(backlog,内核参数 net.core.somaxconn)<br>net.core.somaxconn默认为128<br>net.core.somaxconn 定义了系统级别的全连接队列最大长度，backlog 只是应用层传入的参数，不可能超过内核参数，所以backlog必须小于等于net.core.somaxconn。<br>3.1.1. backlog-应用参数<br>对于Linux而言，基本上任意语言实现的通信框架或服务器程序在构造socket server时，都提供了backlog这个参数，因为在监听端口时，都会调用系统底层API：int listen(int sockfd,int backlog);listen函数中backlog参数的定义如下：<br>Now it specifies the queue length for completely established sockets waiting to be accepted,instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using the tcp_max_syn_backlog sysctl;<br>When syncookies are enabled there is no logical maximum length and this sysctl setting is ignored.<br>if he socket is of AF_INET ,and the backlog argument is greater than the constant SOMAXCONN(129 default),<br>it is silently truncated to SOMAXCONN.<br>backlog 参数描述的是服务器端 TCP ESTABLISHED状态对应的全连接队列长度。<br>3.1.2 net.core.somaxconn-内核参数<br>cat /proc/sys/net/core/somaxconn或者sysctl -a | grep “net.core.somaxconn”线上机器运行结果如下：</li>
</ul>
<p>3.2 查看全连接长度<br>Recv-Q：全连接队列中数据的个数，也是等待被accept的个数<br>Send-Q：全连接队列长度</p>
<p>3.3全连接队满之后的动作<br>1.全连接队满了之后，收到第三次握手的ACK之后首先根据tcp_abort_on_overflow来执行满之后的动作，该参数默认为0.<br>0表示：如果三次握手第三步的时候全连接队列满了那么server扔掉client发过来的ack（在server端认为连接还没有建立起来）<br>1表示：如果全连接队列满了，server发送一个reset包给client，表示丢掉这个握手的过程和这个连接（在server看来连接还未建立）。<br>如果tcp_abort_on_overflow为0，则server直接忽略掉收到的ACK，之后server端不断地重发SYN+ACK。其中tcp_synack_retries参数决定了重试几次才放弃，默认值是5，间隔1s，2s，4s，8s，16s，总共31s，第五次发出后还要等32s才知道第5次也超时了，所以，总共需要31s+32s = 63s,TCP才会把这个连接断开。<br>如果在client上走完第三步，在client看来连接已经建立好了，但server上的对应连接实际没有准备好，这个时候server没有回复，一段时间后，client认为丢包了然后重传包，一直到超时，client报连接异常并主动发fin包断开连接（这个问题也叫client fooling）<br>3.如果tcp_abort_on_overflow为1，则直接响应RST信号，此时客户端报connection reset by peer。<br>3.4.监控全连接队满<br>netstat -s | egrep “listen|LISTEN”<br>ss -ltn Recv-Q &gt; Send-Q<br>4.参数<br>tcp_max_syn_backlog<br>net.core.somaxconn<br>backlog(应用层传入)，java默认为50，freebsd实测为128<br>tcp_synack_retries<br>tcp_abort_on_overflow<br>tcp_syn_retries<br>5.容器中的全连接队列参数<br>tomcat默认短连接，backlog(在tomcat里面属于是Accept count)默认为100<br>nginx默认是 511<br>因为nginx是多进程模式，也就是多个进程都箭筒同一个端口以尽量避免上下文切换来提升性能。<br>打印机631和dns53端口 都是5</p>

        
      </div>
    </div>

  
    </div>
  

  
  
    <div class="post-list">
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/blog/2019/04/16/linux下ss命令和netstat的区别/">
  linux命令下ss命令和netstat的区别
</a>

      </h3>
      

      <div class="article-info">
        <a href="/blog/2019/04/16/linux下ss命令和netstat的区别/"><span class="article-date">
  2019-04-16
</span>
</a>
        
	<span class="article-category tagcloud">
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/linux/">linux</a></li></ul>
	</span>


        

      </div>
      <div class="article-entry">
        
          <h1 id="linux下ss命令和netstat命令的区别"><a href="#linux下ss命令和netstat命令的区别" class="headerlink" title="linux下ss命令和netstat命令的区别"></a>linux下ss命令和netstat命令的区别</h1><p>ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。<br>ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。原因如下：<br>1）当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。<br>2）而ss快的秘诀在于它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢（但仍然比 netstat要快）。</p>

        
      </div>
    </div>

  
    </div>
  



  <div class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="page-number" href="/blog/page/4/">4</a><a class="extend next" rel="next" href="/blog/page/2/">Next</a>
  </div>




          <div class="main-footer">
  
    © 2019 Jacob&#39;s blog - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/blog/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/blog/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/blog/PhotoSwipe/photoswipe.js"></script>
  <script src="/blog/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/blog/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/blog/scripts/main.js"></script>

</body>
</html>
